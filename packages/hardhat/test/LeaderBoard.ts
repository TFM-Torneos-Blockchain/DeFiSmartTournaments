import { expect } from "chai";
import { ethers } from "hardhat";
import { LeaderBoard } from "../typechain-types";
import { getLeaderboard } from "../../nextjs/utils/leader-board/leaderboard"
import { getMerkleRoot } from "../../nextjs/utils/leader-board/merkle_tree_proof"

describe("LeaderBoard and MerkleTree", function () {
  // We define a fixture to reuse the same setup in every test.
  const events = [
    {
      player: "0xc3d688B66703497DAA19211EEdff47f25384cdc3",
      score_number: 333,
    },
    {
      player: "0x11DfADcd62593325Bcf82Ed1f55d87840E93A977",
      score_number: 56565,
    },
    {
      player: "0x74a81F84268744a40FEBc48f8b812a1f188D80C3",
      score_number: 888,
    },
    {
      player: "0xc3d688B66703497DAA19211EEdff47f25384cdc3",
      score_number: 11,
    },
    {
      player: "0x11DfADcd62593325Bcf82Ed1f55d87840E93A977",
      score_number: 15,
    },
  ];
  const backendLeaderBoard = getLeaderboard(0n,events);
  const backendMerkleTree = getMerkleRoot(0,backendLeaderBoard.concatenatedStringBytes,backendLeaderBoard.positions,1);


  let leaderBoard: LeaderBoard;
  beforeEach("Deploy contracts", async () => {
    const [owner] = await ethers.getSigners();
    const LeaderBoardFactory = await ethers.getContractFactory("LeaderBoard");
    leaderBoard = (await LeaderBoardFactory.deploy()) as LeaderBoard;
    await leaderBoard.deployed();
    await leaderBoard.setResult(0, events[0].player, events[0].score_number);
    await leaderBoard.setResult(0, events[1].player, events[1].score_number);
    await leaderBoard.setResult(0, events[2].player, events[2].score_number);
    await leaderBoard.setResult(0, events[3].player,events[3].score_number);
    await leaderBoard.setResult(0, events[4].player,events[4].score_number);
  });

  // describe("Set result", function () {
  it("It should generate the same Sponge Hash as the one generated by the Backend.", async () => {
    const spongeHash = await leaderBoard.getSpongeHash(0);
    expect(spongeHash.toString()).to.equal("0x4fa4099516a67517bb23f9f8e824e8feff79fbefdc697146f5ce2eb775da56ce");
  });
  // });

  // describe("Create Leader Board and Merkle Root", function () {
  it("It should revert due to incorrect player classification ordering.", async () => {
    await expect(
      leaderBoard.createLeaderBoardMerkleTree(
        0,
        backendLeaderBoard.concatenatedStringBytes,
        [1, 2, 4, 0, 3],
      ),
    ).to.be.revertedWith("Data corrupted: incorrect players classification.");
  });
  it("It should revert due to inequality in on-chain and off-chain Sponge Hash.", async () => {
    await expect(
      leaderBoard.createLeaderBoardMerkleTree(
        0,
        "0xc3d678b66703497daa19211eedff47f25394cdc3000000000000000000000000000000000000000000000000000000000000014d11dfadcd62593325bcf82ed1f55d87840e93a977000000000000000000000000000000000000000000000000000000000000dcf574a81f84268744a40febc48f8b812a1f188d80c30000000000000000000000000000000000000000000000000000000000000378c3d688b66703497daa19211eedff47f25384cdc3000000000000000000000000000000000000000000000000000000000000000b11dfadcd62593325bcf82ed1f55d87840e93a977000000000000000000000000000000000000000000000000000000000000000f",
        backendLeaderBoard.positions,
      ),
    ).to.be.revertedWith("Data corrupted: bad spongeHash recreation.");
  });

  it("It should generate the same Merkle Root as the one generated by the Backend.", async () => {
    await leaderBoard.createLeaderBoardMerkleTree(
      0,
      backendLeaderBoard.concatenatedStringBytes,
      backendLeaderBoard.positions,
    );
    const merkleRoot = await leaderBoard.getMerkleRoot(0);
    expect(merkleRoot.toString()).to.equal(backendMerkleTree.root);
  });
  // });
});
